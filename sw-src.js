// Load Workbox from local vendored copy (generated by: deno task setup:workbox)
importScripts('/assets/js/workbox/workbox-v7.3.0/workbox-sw.js');

// Tell workbox-sw to load all modules from local path instead of CDN
workbox.setConfig({ modulePathPrefix: '/assets/js/workbox/workbox-v7.3.0/' });

const { setCacheNameDetails, clientsClaim } = workbox.core;
const { precacheAndRoute, cleanupOutdatedCaches } = workbox.precaching;
const { registerRoute } = workbox.routing;
const { NetworkFirst, StaleWhileRevalidate, CacheFirst } = workbox.strategies;
const { ExpirationPlugin } = workbox.expiration;

// ============================================
// CACHE NAMING
// ============================================
// Static cache names — no version hash so runtime caches persist across deploys.
// Precaching already handles versioning via file-revision hashes.
setCacheNameDetails({ prefix: 'kipukas-pwa' });

// ============================================
// LIFECYCLE: controlled skipWaiting via postMessage
// ============================================
// Do NOT call self.skipWaiting() automatically.
// The client (pwa-update-handler.js) will send a SKIP_WAITING message
// when the user chooses to update, giving them control over the timing.

// Track whether the PWA has been installed (persists for the SW lifetime).
let pwaInstalled = false;

self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }

  // install_pwa.html notifies us when the user completes a PWA install.
  if (event.data && event.data.type === 'PWA_INSTALLED') {
    pwaInstalled = true;
  }

  // install_pwa.html asks us on page load whether the PWA was already installed.
  // Responds on the provided MessageChannel port.
  if (event.data && event.data.type === 'PWA_INSTALL_CHECK') {
    if (event.ports && event.ports[0]) {
      event.ports[0].postMessage({ installed: pwaInstalled });
    }
  }
});

clientsClaim();

// ============================================
// PRECACHING
// ============================================
// The placeholder below is replaced at build time by workbox-cli
// injectManifest with the list of revisioned URLs.
precacheAndRoute(self.__WB_MANIFEST, {
  ignoreURLParametersMatching: [/^utm_/, /^fbclid$/],
});
cleanupOutdatedCaches();

// ============================================
// WASM API ROUTES — relay /api/* to page → Web Worker → WASM
// ============================================
// HTMX makes real fetch() calls to /api/* endpoints.
// This route intercepts them and relays to the page's kipukas-api.js bridge,
// which forwards to the WASM Web Worker for processing.
// A MessageChannel provides a direct response path from the worker back to here.
const wasmApiMatcher = ({url}) => url.pathname.startsWith('/api/');
const wasmApiHandler = async ({request, event}) => {
    const client = await self.clients.get(event.clientId);
    if (!client) {
      return new Response(
        '<span class="text-kip-red">No controlling page found for WASM relay</span>',
        { status: 503, headers: { 'Content-Type': 'text/html; charset=utf-8' } }
      );
    }

    const url = new URL(request.url);

    // Read request body for POST/PUT/PATCH methods (Phase 2: needed for future POST routes)
    const body = ['POST', 'PUT', 'PATCH'].includes(request.method)
      ? await request.text()
      : '';

    return new Promise((resolve, reject) => {
      const channel = new MessageChannel();

      // Timeout: if the worker doesn't respond in 5s, fail gracefully
      const timeout = setTimeout(() => {
        reject(new Response(
          '<span class="text-kip-red">WASM request timed out</span>',
          { status: 504, headers: { 'Content-Type': 'text/html; charset=utf-8' } }
        ));
      }, 5000);

      channel.port1.onmessage = (msg) => {
        clearTimeout(timeout);
        resolve(new Response(msg.data.html, {
          status: msg.data.ok ? 200 : 500,
          headers: { 'Content-Type': 'text/html; charset=utf-8' },
        }));
      };

      // Send the request details + one end of the channel to the page.
      // The page's kipukas-api.js will transfer port2 to the WASM Web Worker.
      client.postMessage({
        type: 'WASM_REQUEST',
        method: request.method,
        pathname: url.pathname,
        search: url.search,
        body: body,
      }, [channel.port2]);
    });
  };

// Register for all HTTP methods (Workbox registerRoute defaults to GET only)
registerRoute(wasmApiMatcher, wasmApiHandler);         // GET
registerRoute(wasmApiMatcher, wasmApiHandler, 'POST');  // POST
registerRoute(wasmApiMatcher, wasmApiHandler, 'PUT');   // PUT
registerRoute(wasmApiMatcher, wasmApiHandler, 'PATCH'); // PATCH

// ============================================
// RUNTIME CACHING STRATEGIES
// ============================================

// Strategy 1: HTML Pages — NetworkFirst (fresh content is critical)
registerRoute(
  /\.(?:html)$/,
  new NetworkFirst({
    cacheName: 'kipukas-pages',
    networkTimeoutSeconds: 3,
    matchOptions: { ignoreSearch: true },
    plugins: [
      {
        cacheWillUpdate: async ({ response }) =>
          response && response.status === 200 ? response : null,
      },
    ],
  })
);

// Strategy 2: Static Assets (CSS, JS, WASM) — StaleWhileRevalidate
registerRoute(
  /\.(?:css|js|wasm)$/,
  new StaleWhileRevalidate({
    cacheName: 'kipukas-assets',
    plugins: [
      {
        cacheWillUpdate: async ({ response }) =>
          response && response.status === 200 ? response : null,
      },
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// Strategy 3: Images — CacheFirst (images rarely change)
registerRoute(
  /\.(?:png|jpg|jpeg|svg|gif|webp|ico)$/,
  new CacheFirst({
    cacheName: 'kipukas-images',
    plugins: [
      {
        cacheWillUpdate: async ({ response }) =>
          response && response.status === 200 ? response : null,
      },
      new ExpirationPlugin({
        maxEntries: 500,
        maxAgeSeconds: 60 * 24 * 60 * 60, // 60 days
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// Strategy 4: Google Fonts — CacheFirst with long expiration
registerRoute(
  /^https:\/\/fonts\.(?:googleapis|gstatic)\.com\/.*/i,
  new CacheFirst({
    cacheName: 'kipukas-fonts',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
      }),
    ],
  })
);

// ============================================
// CLEANUP: remove old versioned runtime caches from the previous setup
// ============================================
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) =>
      Promise.all(
        cacheNames
          .filter((name) => {
            // Delete any old runtime caches that contain a version hash
            // (the old format was kipukas-{type}-{hash}_{date})
            const isOldVersionedCache =
              name.startsWith('kipukas-') &&
              /kipukas-(?:pages|assets|images|fonts)-[a-f0-9]{64}/.test(name);
            // Also delete the old "my-app-cache-" prefix from the backup config
            const isLegacyCache = name.startsWith('my-app-cache-');
            return isOldVersionedCache || isLegacyCache;
          })
          .map((name) => {
            console.log('[SW] Deleting old cache:', name);
            return caches.delete(name);
          })
      )
    )
  );
});
