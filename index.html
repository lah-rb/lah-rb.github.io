---
layout: default
permalink: /
title: "Binder Home"
description: "This is the home of all the cards ever produced by Kipukas! Whether
you are planning you next dominating game strategy or browsing for lovely pieces of
art you came to the right place."
bg-terra: "bg-hero-pattern "
---

{% include toolbar.html 
  qr_scanner=true 
  local_fists_tool=true
  multiplayer_fists_tool_home=true
  multiplayer_home=true
  lastPage=true
  hamburger=true
  filter=true
  turn_tracker=true
  install_pwa=true
  logo=true
  hideTools=true
  search=true
  base_fill='fill-kip-goldenrod'
  base_stroke='stroke-kip-goldenrod'
  background_color='bg-slate-100/80'
%}

<!-- Card grid: HTMX infinite scroll powered by WASM /api/cards -->
<!-- Uses CSS Grid with dynamic batch sizing based on viewport -->
 <template x-if="true">
  <!-- Mobile: 160px min, Desktop (md+): 200px min for better desktop experience -->
  <div id="card-grid"
    class="grid gap-5 justify-items-center px-4 grid-cols-[repeat(auto-fill,minmax(200px,1fr))]"
    hx-get="/api/cards?page=0&per=12&all=true"
    hx-trigger="load"
    hx-swap="innerHTML swap:150ms"></div>
  </div>
</template>
<!-- Idiomorph extension for smooth DOM morphing on filter/search (bundled locally) -->
<script src="/assets/js/idiomorph-ext.min.js" defer></script>

<script>
  // Dynamic batch sizing based on viewport
  // Calculates optimal number of cards to load based on visible grid columns
  window.kipukasBatchSize = (function() {
    var cardMinWidth = 160; // minmax(160px, 1fr)
    var gap = 20; // gap-5 = 1.25rem = 20px
    var padding = 32; // px-4 = 1rem = 16px each side = 32px total
    var desiredRows = 3; // Load 3 rows at a time for smooth scrolling

    function calculateBatchSize() {
      var viewportWidth = window.innerWidth;
      var availableWidth = viewportWidth - padding;
      var cardsPerRow = Math.floor((availableWidth + gap) / (cardMinWidth + gap));
      // Ensure at least 2 cards per row on very small screens
      cardsPerRow = Math.max(cardsPerRow, 2);
      return cardsPerRow * desiredRows;
    }

    return {
      get: calculateBatchSize,
      getColumns: function() {
        var viewportWidth = window.innerWidth;
        var availableWidth = viewportWidth - padding;
        return Math.max(Math.floor((availableWidth + gap) / (cardMinWidth + gap)), 2);
      }
    };
  })();

  // Update initial load with dynamic batch size
  document.addEventListener('DOMContentLoaded', function() {
    var cardGrid = document.getElementById('card-grid');
    if (cardGrid) {
      var optimalBatch = window.kipukasBatchSize.get();
      // Update the hx-get attribute with optimal batch size
      var currentUrl = cardGrid.getAttribute('hx-get');
      var newUrl = currentUrl.replace(/per=\d+/, 'per=' + optimalBatch);
      cardGrid.setAttribute('hx-get', newUrl);
    }
  });

  // Called by filter checkboxes and search input to refresh the card grid.
  // Reads Alpine reactive state, builds query string, calls htmx.ajax()
  // through the same WASM bridge path (Phase 2 lesson #4).
  window.kipukasRefreshCards = function() {
    if (typeof Alpine === 'undefined' || typeof htmx === 'undefined') return;

    var data = Alpine.$data(document.body);
    var filter = data.filter || {};
    var search = (data.searchQuery || '').trim();
    
    // Use dynamic batch size based on viewport
    var optimalBatch = window.kipukasBatchSize ? window.kipukasBatchSize.get() : 12;
    var params = ['page=0', 'per=' + optimalBatch];

    if (search) {
      // Search mode: search across all cards regardless of filters
      params.push('search=' + encodeURIComponent(search));
    } else if (filter.all) {
      // Show All mode
      params.push('all=true');
    } else {
      // Filter mode: collect active filter keys
      var active = [];
      var keys = Object.keys(filter);
      for (var i = 0; i < keys.length; i++) {
        if (keys[i] !== 'all' && filter[keys[i]] === true) {
          active.push(keys[i]);
        }
      }
      if (active.length > 0) {
        params.push('filter=' + encodeURIComponent(active.join(',')));
      }
      // If no active filters, params has no filter/all/search â†’ WASM returns empty grid
    }

    var url = '/api/cards?' + params.join('&');
    // Use morph swap for filter/search to preserve DOM state where possible
    htmx.ajax('GET', url, {target: '#card-grid', swap: 'morph:innerHTML'});
  };

  // Image preloading for smoother infinite scroll experience
  // Preloads images from the next batch when cards are rendered
  document.addEventListener('htmx:afterSwap', function(evt) {
    // Only process card grid updates
    if (!evt.detail.target || evt.detail.target.id !== 'card-grid') return;

    // Find all image srcset URLs in the newly added content and preload them
    var images = evt.detail.target.querySelectorAll('img[srcset]');
    images.forEach(function(img) {
      // Preload the image
      var preloadImg = new Image();
      preloadImg.src = img.src;
    });

    // Look for sentinel and preload next batch images (if any are embedded in response)
    var sentinel = evt.detail.target.querySelector('[data-scroll-load="true"]');
    if (sentinel && sentinel.dataset.nextImages) {
      try {
        var nextImages = JSON.parse(sentinel.dataset.nextImages);
        nextImages.forEach(function(src) {
          var img = new Image();
          img.src = src;
        });
      } catch (e) {
        // Silently fail if parsing fails
      }
    }
  });
</script>
